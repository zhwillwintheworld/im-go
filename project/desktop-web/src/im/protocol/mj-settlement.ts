// automatically generated by the FlatBuffers compiler, do not modify

/* eslint-disable @typescript-eslint/no-unused-vars, @typescript-eslint/no-explicit-any, @typescript-eslint/no-non-null-assertion */

import * as flatbuffers from 'flatbuffers';

import { MahjongTile } from '../../im/protocol/mahjong-tile.js';


export class MjSettlement {
  bb: flatbuffers.ByteBuffer|null = null;
  bb_pos = 0;
  __init(i:number, bb:flatbuffers.ByteBuffer):MjSettlement {
  this.bb_pos = i;
  this.bb = bb;
  return this;
}

static getRootAsMjSettlement(bb:flatbuffers.ByteBuffer, obj?:MjSettlement):MjSettlement {
  return (obj || new MjSettlement()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

static getSizePrefixedRootAsMjSettlement(bb:flatbuffers.ByteBuffer, obj?:MjSettlement):MjSettlement {
  bb.setPosition(bb.position() + flatbuffers.SIZE_PREFIX_LENGTH);
  return (obj || new MjSettlement()).__init(bb.readInt32(bb.position()) + bb.position(), bb);
}

winnerSeat():number {
  const offset = this.bb!.__offset(this.bb_pos, 4);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

winType():number {
  const offset = this.bb!.__offset(this.bb_pos, 6);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

loserSeat():number {
  const offset = this.bb!.__offset(this.bb_pos, 8);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

scoreChanges(index: number):number|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.readInt32(this.bb!.__vector(this.bb_pos + offset) + index * 4) : 0;
}

scoreChangesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

scoreChangesArray():Int32Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 10);
  return offset ? new Int32Array(this.bb!.bytes().buffer, this.bb!.bytes().byteOffset + this.bb!.__vector(this.bb_pos + offset), this.bb!.__vector_len(this.bb_pos + offset)) : null;
}

winningTiles(index: number, obj?:MahjongTile):MahjongTile|null {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? (obj || new MahjongTile()).__init(this.bb!.__indirect(this.bb!.__vector(this.bb_pos + offset) + index * 4), this.bb!) : null;
}

winningTilesLength():number {
  const offset = this.bb!.__offset(this.bb_pos, 12);
  return offset ? this.bb!.__vector_len(this.bb_pos + offset) : 0;
}

fanDescription():string|null
fanDescription(optionalEncoding:flatbuffers.Encoding):string|Uint8Array|null
fanDescription(optionalEncoding?:any):string|Uint8Array|null {
  const offset = this.bb!.__offset(this.bb_pos, 14);
  return offset ? this.bb!.__string(this.bb_pos + offset, optionalEncoding) : null;
}

fanCount():number {
  const offset = this.bb!.__offset(this.bb_pos, 16);
  return offset ? this.bb!.readInt32(this.bb_pos + offset) : 0;
}

static startMjSettlement(builder:flatbuffers.Builder) {
  builder.startObject(7);
}

static addWinnerSeat(builder:flatbuffers.Builder, winnerSeat:number) {
  builder.addFieldInt32(0, winnerSeat, 0);
}

static addWinType(builder:flatbuffers.Builder, winType:number) {
  builder.addFieldInt32(1, winType, 0);
}

static addLoserSeat(builder:flatbuffers.Builder, loserSeat:number) {
  builder.addFieldInt32(2, loserSeat, 0);
}

static addScoreChanges(builder:flatbuffers.Builder, scoreChangesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(3, scoreChangesOffset, 0);
}

static createScoreChangesVector(builder:flatbuffers.Builder, data:number[]|Int32Array):flatbuffers.Offset;
/**
 * @deprecated This Uint8Array overload will be removed in the future.
 */
static createScoreChangesVector(builder:flatbuffers.Builder, data:number[]|Uint8Array):flatbuffers.Offset;
static createScoreChangesVector(builder:flatbuffers.Builder, data:number[]|Int32Array|Uint8Array):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addInt32(data[i]!);
  }
  return builder.endVector();
}

static startScoreChangesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addWinningTiles(builder:flatbuffers.Builder, winningTilesOffset:flatbuffers.Offset) {
  builder.addFieldOffset(4, winningTilesOffset, 0);
}

static createWinningTilesVector(builder:flatbuffers.Builder, data:flatbuffers.Offset[]):flatbuffers.Offset {
  builder.startVector(4, data.length, 4);
  for (let i = data.length - 1; i >= 0; i--) {
    builder.addOffset(data[i]!);
  }
  return builder.endVector();
}

static startWinningTilesVector(builder:flatbuffers.Builder, numElems:number) {
  builder.startVector(4, numElems, 4);
}

static addFanDescription(builder:flatbuffers.Builder, fanDescriptionOffset:flatbuffers.Offset) {
  builder.addFieldOffset(5, fanDescriptionOffset, 0);
}

static addFanCount(builder:flatbuffers.Builder, fanCount:number) {
  builder.addFieldInt32(6, fanCount, 0);
}

static endMjSettlement(builder:flatbuffers.Builder):flatbuffers.Offset {
  const offset = builder.endObject();
  return offset;
}

static createMjSettlement(builder:flatbuffers.Builder, winnerSeat:number, winType:number, loserSeat:number, scoreChangesOffset:flatbuffers.Offset, winningTilesOffset:flatbuffers.Offset, fanDescriptionOffset:flatbuffers.Offset, fanCount:number):flatbuffers.Offset {
  MjSettlement.startMjSettlement(builder);
  MjSettlement.addWinnerSeat(builder, winnerSeat);
  MjSettlement.addWinType(builder, winType);
  MjSettlement.addLoserSeat(builder, loserSeat);
  MjSettlement.addScoreChanges(builder, scoreChangesOffset);
  MjSettlement.addWinningTiles(builder, winningTilesOffset);
  MjSettlement.addFanDescription(builder, fanDescriptionOffset);
  MjSettlement.addFanCount(builder, fanCount);
  return MjSettlement.endMjSettlement(builder);
}
}
